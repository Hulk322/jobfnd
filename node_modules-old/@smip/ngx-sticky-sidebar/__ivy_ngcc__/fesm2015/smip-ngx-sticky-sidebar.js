import { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Directive, ElementRef, Input, Output, HostListener, NgModule } from '@angular/core';
import StickySidebar from 'sticky-sidebar';
import 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
function StickySidebarConfig() { }
if (false) {
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.topSpacing;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.bottomSpacing;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.resizeSensor;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.containerSelector;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.innerWrapperSelector;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.stickyClass;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.minWidth;
}
/** @type {?} */
const STICKY_SYDEBAR_CONFIG = new InjectionToken('stickySidebarConfig');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultConfig = {
    topSpacing: 0,
    bottomSpacing: 0,
    resizeSensor: true,
    containerSelector: '',
    innerWrapperSelector: '.inner-wrapper-sticky',
    stickyClass: 'is-affixed',
    minWidth: 0,
};
class SidebarService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config ? Object.assign({}, defaultConfig, config) : defaultConfig;
    }
}
SidebarService.ɵfac = function SidebarService_Factory(t) { return new (t || SidebarService)(ɵngcc0.ɵɵinject(STICKY_SYDEBAR_CONFIG, 8)); };
SidebarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: SidebarService, factory: SidebarService.ɵfac, providedIn: 'root' });
/** @nocollapse */
SidebarService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [STICKY_SYDEBAR_CONFIG,] }] }
];
/** @nocollapse */ SidebarService.ngInjectableDef = ɵɵdefineInjectable({ factory: function SidebarService_Factory() { return new SidebarService(ɵɵinject(STICKY_SYDEBAR_CONFIG, 8)); }, token: SidebarService, providedIn: "root" });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [STICKY_SYDEBAR_CONFIG]
            }] }]; }, null); })();
if (false) {
    /** @type {?} */
    SidebarService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarDirective {
    /**
     * @param {?} element
     * @param {?} sidebarConfig
     */
    constructor(element, sidebarConfig) {
        this.element = element;
        this.sidebarConfig = sidebarConfig;
        this.topSpacing = this.sidebarConfig.config.topSpacing;
        this.bottomSpacing = this.sidebarConfig.config.bottomSpacing;
        this.resizeSensor = this.sidebarConfig.config.resizeSensor;
        this.containerSelector = this.sidebarConfig.config.containerSelector;
        this.innerWrapperSelector = this.sidebarConfig.config.innerWrapperSelector;
        this.stickyClass = this.sidebarConfig.config.stickyClass;
        this.minWidth = this.sidebarConfig.config.minWidth;
        this.stickySidebarAffixTop = new EventEmitter();
        this.stickySidebarAffixedTop = new EventEmitter();
        this.stickySidebarAffixBottom = new EventEmitter();
        this.stickySidebarAffixedBottom = new EventEmitter();
        this.stickySidebarAffixContainerBottom = new EventEmitter();
        this.stickySidebarAffixedContainerBottom = new EventEmitter();
        this.stickySidebarAffixUnbottom = new EventEmitter();
        this.stickySidebarAffixedUnbottom = new EventEmitter();
        this.stickySidebarAffixStatic = new EventEmitter();
        this.stickySidebarAffixedStatic = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.stickySidebar = new StickySidebar(this.element.nativeElement, {
            topSpacing: +this.topSpacing,
            bottomSpacing: +this.bottomSpacing,
            containerSelector: this.containerSelector,
            innerWrapperSelector: this.innerWrapperSelector,
            resizeSensor: this.resizeSensor,
            stickyClass: this.stickyClass,
            minWidth: +this.minWidth,
        });
        if (this.updateSticky) {
            this.updateSticky.subscribe((/**
             * @return {?}
             */
            () => {
                this.stickySidebar.updateSticky();
            }));
        }
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixTop() {
        this.stickySidebarAffixTop.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedTop() {
        this.stickySidebarAffixedTop.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixBottom() {
        this.stickySidebarAffixBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedBottom() {
        this.stickySidebarAffixedBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixContainerBottom() {
        this.stickySidebarAffixContainerBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedContainerBottom() {
        this.stickySidebarAffixedContainerBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixUnbottom() {
        this.stickySidebarAffixUnbottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedUnbottom() {
        this.stickySidebarAffixedUnbottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixStatic() {
        this.stickySidebarAffixStatic.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedStatic() {
        this.stickySidebarAffixedStatic.emit();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.stickySidebar) {
            this.stickySidebar.destroy();
        }
    }
}
SidebarDirective.ɵfac = function SidebarDirective_Factory(t) { return new (t || SidebarDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SidebarService)); };
SidebarDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SidebarDirective, selectors: [["", "stickySidebar", ""]], hostBindings: function SidebarDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("affix.top.stickySidebar", function SidebarDirective_affix_top_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixTop(); })("affixed.top.stickySidebar", function SidebarDirective_affixed_top_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixedTop(); })("affix.bottom.stickySidebar", function SidebarDirective_affix_bottom_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixBottom(); })("affixed.bottom.stickySidebar", function SidebarDirective_affixed_bottom_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixedBottom(); })("affix.container-bottom.stickySidebar", function SidebarDirective_affix_container_bottom_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixContainerBottom(); })("affixed.container-bottom.stickySidebar", function SidebarDirective_affixed_container_bottom_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixedContainerBottom(); })("affix.unbottom.stickySidebar", function SidebarDirective_affix_unbottom_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixUnbottom(); })("affixed.unbottom.stickySidebar", function SidebarDirective_affixed_unbottom_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixedUnbottom(); })("affix.static.stickySidebar", function SidebarDirective_affix_static_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixStatic(); })("affixed.static.stickySidebar", function SidebarDirective_affixed_static_stickySidebar_HostBindingHandler() { return ctx.onStickySidebarAffixedStatic(); });
    } }, inputs: { topSpacing: "topSpacing", bottomSpacing: "bottomSpacing", resizeSensor: "resizeSensor", containerSelector: "containerSelector", innerWrapperSelector: "innerWrapperSelector", stickyClass: "stickyClass", minWidth: "minWidth", updateSticky: "updateSticky" }, outputs: { stickySidebarAffixTop: "stickySidebarAffixTop", stickySidebarAffixedTop: "stickySidebarAffixedTop", stickySidebarAffixBottom: "stickySidebarAffixBottom", stickySidebarAffixedBottom: "stickySidebarAffixedBottom", stickySidebarAffixContainerBottom: "stickySidebarAffixContainerBottom", stickySidebarAffixedContainerBottom: "stickySidebarAffixedContainerBottom", stickySidebarAffixUnbottom: "stickySidebarAffixUnbottom", stickySidebarAffixedUnbottom: "stickySidebarAffixedUnbottom", stickySidebarAffixStatic: "stickySidebarAffixStatic", stickySidebarAffixedStatic: "stickySidebarAffixedStatic" } });
/** @nocollapse */
SidebarDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: SidebarService }
];
SidebarDirective.propDecorators = {
    topSpacing: [{ type: Input }],
    bottomSpacing: [{ type: Input }],
    resizeSensor: [{ type: Input }],
    containerSelector: [{ type: Input }],
    innerWrapperSelector: [{ type: Input }],
    stickyClass: [{ type: Input }],
    minWidth: [{ type: Input }],
    updateSticky: [{ type: Input }],
    stickySidebarAffixTop: [{ type: Output }],
    stickySidebarAffixedTop: [{ type: Output }],
    stickySidebarAffixBottom: [{ type: Output }],
    stickySidebarAffixedBottom: [{ type: Output }],
    stickySidebarAffixContainerBottom: [{ type: Output }],
    stickySidebarAffixedContainerBottom: [{ type: Output }],
    stickySidebarAffixUnbottom: [{ type: Output }],
    stickySidebarAffixedUnbottom: [{ type: Output }],
    stickySidebarAffixStatic: [{ type: Output }],
    stickySidebarAffixedStatic: [{ type: Output }],
    onStickySidebarAffixTop: [{ type: HostListener, args: ['affix.top.stickySidebar',] }],
    onStickySidebarAffixedTop: [{ type: HostListener, args: ['affixed.top.stickySidebar',] }],
    onStickySidebarAffixBottom: [{ type: HostListener, args: ['affix.bottom.stickySidebar',] }],
    onStickySidebarAffixedBottom: [{ type: HostListener, args: ['affixed.bottom.stickySidebar',] }],
    onStickySidebarAffixContainerBottom: [{ type: HostListener, args: ['affix.container-bottom.stickySidebar',] }],
    onStickySidebarAffixedContainerBottom: [{ type: HostListener, args: ['affixed.container-bottom.stickySidebar',] }],
    onStickySidebarAffixUnbottom: [{ type: HostListener, args: ['affix.unbottom.stickySidebar',] }],
    onStickySidebarAffixedUnbottom: [{ type: HostListener, args: ['affixed.unbottom.stickySidebar',] }],
    onStickySidebarAffixStatic: [{ type: HostListener, args: ['affix.static.stickySidebar',] }],
    onStickySidebarAffixedStatic: [{ type: HostListener, args: ['affixed.static.stickySidebar',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SidebarDirective, [{
        type: Directive,
        args: [{
                selector: '[stickySidebar]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: SidebarService }]; }, { topSpacing: [{
            type: Input
        }], bottomSpacing: [{
            type: Input
        }], resizeSensor: [{
            type: Input
        }], containerSelector: [{
            type: Input
        }], innerWrapperSelector: [{
            type: Input
        }], stickyClass: [{
            type: Input
        }], minWidth: [{
            type: Input
        }], stickySidebarAffixTop: [{
            type: Output
        }], stickySidebarAffixedTop: [{
            type: Output
        }], stickySidebarAffixBottom: [{
            type: Output
        }], stickySidebarAffixedBottom: [{
            type: Output
        }], stickySidebarAffixContainerBottom: [{
            type: Output
        }], stickySidebarAffixedContainerBottom: [{
            type: Output
        }], stickySidebarAffixUnbottom: [{
            type: Output
        }], stickySidebarAffixedUnbottom: [{
            type: Output
        }], stickySidebarAffixStatic: [{
            type: Output
        }], stickySidebarAffixedStatic: [{
            type: Output
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixTop: [{
            type: HostListener,
            args: ['affix.top.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixedTop: [{
            type: HostListener,
            args: ['affixed.top.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixBottom: [{
            type: HostListener,
            args: ['affix.bottom.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixedBottom: [{
            type: HostListener,
            args: ['affixed.bottom.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixContainerBottom: [{
            type: HostListener,
            args: ['affix.container-bottom.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixedContainerBottom: [{
            type: HostListener,
            args: ['affixed.container-bottom.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixUnbottom: [{
            type: HostListener,
            args: ['affix.unbottom.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixedUnbottom: [{
            type: HostListener,
            args: ['affixed.unbottom.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixStatic: [{
            type: HostListener,
            args: ['affix.static.stickySidebar']
        }], 
    /**
     * @return {?}
     */
    onStickySidebarAffixedStatic: [{
            type: HostListener,
            args: ['affixed.static.stickySidebar']
        }], updateSticky: [{
            type: Input
        }] }); })();
if (false) {
    /** @type {?} */
    SidebarDirective.prototype.topSpacing;
    /** @type {?} */
    SidebarDirective.prototype.bottomSpacing;
    /** @type {?} */
    SidebarDirective.prototype.resizeSensor;
    /** @type {?} */
    SidebarDirective.prototype.containerSelector;
    /** @type {?} */
    SidebarDirective.prototype.innerWrapperSelector;
    /** @type {?} */
    SidebarDirective.prototype.stickyClass;
    /** @type {?} */
    SidebarDirective.prototype.minWidth;
    /** @type {?} */
    SidebarDirective.prototype.updateSticky;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixTop;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedTop;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixContainerBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedContainerBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixUnbottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedUnbottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixStatic;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedStatic;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebar;
    /**
     * @type {?}
     * @private
     */
    SidebarDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    SidebarDirective.prototype.sidebarConfig;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxStickySidebarModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static withConfig(config) {
        return {
            ngModule: NgxStickySidebarModule,
            providers: [
                { provide: STICKY_SYDEBAR_CONFIG, useValue: config },
            ],
        };
    }
}
NgxStickySidebarModule.ɵfac = function NgxStickySidebarModule_Factory(t) { return new (t || NgxStickySidebarModule)(); };
NgxStickySidebarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxStickySidebarModule });
NgxStickySidebarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxStickySidebarModule, { declarations: [SidebarDirective], exports: [SidebarDirective] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxStickySidebarModule, [{
        type: NgModule,
        args: [{
                declarations: [SidebarDirective],
                imports: [],
                exports: [SidebarDirective]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxStickySidebarModule, SidebarDirective as ɵa, SidebarService as ɵb, STICKY_SYDEBAR_CONFIG as ɵd };

//# sourceMappingURL=smip-ngx-sticky-sidebar.js.map