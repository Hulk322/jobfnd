import { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Directive, ElementRef, Input, Output, HostListener, NgModule } from '@angular/core';
import StickySidebar from 'sticky-sidebar';
import 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function StickySidebarConfig() { }
if (false) {
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.topSpacing;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.bottomSpacing;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.resizeSensor;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.containerSelector;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.innerWrapperSelector;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.stickyClass;
    /** @type {?|undefined} */
    StickySidebarConfig.prototype.minWidth;
}
/** @type {?} */
const STICKY_SYDEBAR_CONFIG = new InjectionToken('stickySidebarConfig');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultConfig = {
    topSpacing: 0,
    bottomSpacing: 0,
    resizeSensor: true,
    containerSelector: '',
    innerWrapperSelector: '.inner-wrapper-sticky',
    stickyClass: 'is-affixed',
    minWidth: 0,
};
class SidebarService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.config = config ? Object.assign({}, defaultConfig, config) : defaultConfig;
    }
}
SidebarService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
SidebarService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [STICKY_SYDEBAR_CONFIG,] }] }
];
/** @nocollapse */ SidebarService.ngInjectableDef = ɵɵdefineInjectable({ factory: function SidebarService_Factory() { return new SidebarService(ɵɵinject(STICKY_SYDEBAR_CONFIG, 8)); }, token: SidebarService, providedIn: "root" });
if (false) {
    /** @type {?} */
    SidebarService.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SidebarDirective {
    /**
     * @param {?} element
     * @param {?} sidebarConfig
     */
    constructor(element, sidebarConfig) {
        this.element = element;
        this.sidebarConfig = sidebarConfig;
        this.topSpacing = this.sidebarConfig.config.topSpacing;
        this.bottomSpacing = this.sidebarConfig.config.bottomSpacing;
        this.resizeSensor = this.sidebarConfig.config.resizeSensor;
        this.containerSelector = this.sidebarConfig.config.containerSelector;
        this.innerWrapperSelector = this.sidebarConfig.config.innerWrapperSelector;
        this.stickyClass = this.sidebarConfig.config.stickyClass;
        this.minWidth = this.sidebarConfig.config.minWidth;
        this.stickySidebarAffixTop = new EventEmitter();
        this.stickySidebarAffixedTop = new EventEmitter();
        this.stickySidebarAffixBottom = new EventEmitter();
        this.stickySidebarAffixedBottom = new EventEmitter();
        this.stickySidebarAffixContainerBottom = new EventEmitter();
        this.stickySidebarAffixedContainerBottom = new EventEmitter();
        this.stickySidebarAffixUnbottom = new EventEmitter();
        this.stickySidebarAffixedUnbottom = new EventEmitter();
        this.stickySidebarAffixStatic = new EventEmitter();
        this.stickySidebarAffixedStatic = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.stickySidebar = new StickySidebar(this.element.nativeElement, {
            topSpacing: +this.topSpacing,
            bottomSpacing: +this.bottomSpacing,
            containerSelector: this.containerSelector,
            innerWrapperSelector: this.innerWrapperSelector,
            resizeSensor: this.resizeSensor,
            stickyClass: this.stickyClass,
            minWidth: +this.minWidth,
        });
        if (this.updateSticky) {
            this.updateSticky.subscribe((/**
             * @return {?}
             */
            () => {
                this.stickySidebar.updateSticky();
            }));
        }
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixTop() {
        this.stickySidebarAffixTop.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedTop() {
        this.stickySidebarAffixedTop.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixBottom() {
        this.stickySidebarAffixBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedBottom() {
        this.stickySidebarAffixedBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixContainerBottom() {
        this.stickySidebarAffixContainerBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedContainerBottom() {
        this.stickySidebarAffixedContainerBottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixUnbottom() {
        this.stickySidebarAffixUnbottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedUnbottom() {
        this.stickySidebarAffixedUnbottom.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixStatic() {
        this.stickySidebarAffixStatic.emit();
    }
    /**
     * @return {?}
     */
    onStickySidebarAffixedStatic() {
        this.stickySidebarAffixedStatic.emit();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.stickySidebar) {
            this.stickySidebar.destroy();
        }
    }
}
SidebarDirective.decorators = [
    { type: Directive, args: [{
                selector: '[stickySidebar]',
            },] }
];
/** @nocollapse */
SidebarDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: SidebarService }
];
SidebarDirective.propDecorators = {
    topSpacing: [{ type: Input }],
    bottomSpacing: [{ type: Input }],
    resizeSensor: [{ type: Input }],
    containerSelector: [{ type: Input }],
    innerWrapperSelector: [{ type: Input }],
    stickyClass: [{ type: Input }],
    minWidth: [{ type: Input }],
    updateSticky: [{ type: Input }],
    stickySidebarAffixTop: [{ type: Output }],
    stickySidebarAffixedTop: [{ type: Output }],
    stickySidebarAffixBottom: [{ type: Output }],
    stickySidebarAffixedBottom: [{ type: Output }],
    stickySidebarAffixContainerBottom: [{ type: Output }],
    stickySidebarAffixedContainerBottom: [{ type: Output }],
    stickySidebarAffixUnbottom: [{ type: Output }],
    stickySidebarAffixedUnbottom: [{ type: Output }],
    stickySidebarAffixStatic: [{ type: Output }],
    stickySidebarAffixedStatic: [{ type: Output }],
    onStickySidebarAffixTop: [{ type: HostListener, args: ['affix.top.stickySidebar',] }],
    onStickySidebarAffixedTop: [{ type: HostListener, args: ['affixed.top.stickySidebar',] }],
    onStickySidebarAffixBottom: [{ type: HostListener, args: ['affix.bottom.stickySidebar',] }],
    onStickySidebarAffixedBottom: [{ type: HostListener, args: ['affixed.bottom.stickySidebar',] }],
    onStickySidebarAffixContainerBottom: [{ type: HostListener, args: ['affix.container-bottom.stickySidebar',] }],
    onStickySidebarAffixedContainerBottom: [{ type: HostListener, args: ['affixed.container-bottom.stickySidebar',] }],
    onStickySidebarAffixUnbottom: [{ type: HostListener, args: ['affix.unbottom.stickySidebar',] }],
    onStickySidebarAffixedUnbottom: [{ type: HostListener, args: ['affixed.unbottom.stickySidebar',] }],
    onStickySidebarAffixStatic: [{ type: HostListener, args: ['affix.static.stickySidebar',] }],
    onStickySidebarAffixedStatic: [{ type: HostListener, args: ['affixed.static.stickySidebar',] }]
};
if (false) {
    /** @type {?} */
    SidebarDirective.prototype.topSpacing;
    /** @type {?} */
    SidebarDirective.prototype.bottomSpacing;
    /** @type {?} */
    SidebarDirective.prototype.resizeSensor;
    /** @type {?} */
    SidebarDirective.prototype.containerSelector;
    /** @type {?} */
    SidebarDirective.prototype.innerWrapperSelector;
    /** @type {?} */
    SidebarDirective.prototype.stickyClass;
    /** @type {?} */
    SidebarDirective.prototype.minWidth;
    /** @type {?} */
    SidebarDirective.prototype.updateSticky;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixTop;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedTop;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixContainerBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedContainerBottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixUnbottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedUnbottom;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixStatic;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebarAffixedStatic;
    /** @type {?} */
    SidebarDirective.prototype.stickySidebar;
    /**
     * @type {?}
     * @private
     */
    SidebarDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    SidebarDirective.prototype.sidebarConfig;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxStickySidebarModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static withConfig(config) {
        return {
            ngModule: NgxStickySidebarModule,
            providers: [
                { provide: STICKY_SYDEBAR_CONFIG, useValue: config },
            ],
        };
    }
}
NgxStickySidebarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SidebarDirective],
                imports: [],
                exports: [SidebarDirective],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxStickySidebarModule, SidebarDirective as ɵa, SidebarService as ɵb, STICKY_SYDEBAR_CONFIG as ɵd };
//# sourceMappingURL=smip-ngx-sticky-sidebar.js.map
