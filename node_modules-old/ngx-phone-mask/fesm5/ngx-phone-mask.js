import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ɵgetDOM } from '@angular/platform-browser';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';
import { Directive, ElementRef, forwardRef, HostListener, Inject, Input, Optional, Renderer2, Pipe, NgModule } from '@angular/core';
import { conformToMask, TextMaskModule } from 'angular2-text-mask';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var clean = function (number) {
    return number
        .toString()
        .replace(/[^\d\^\+]/gm, '');
};
/** @type {?} */
var mask = function (maxLength) {
    if (maxLength === void 0) { maxLength = 13; }
    return function (rawValue) {
        if (clean(rawValue).length <= 12 || maxLength === 12) {
            return ['+', /[1-9]/, ' ', '(', /[1-9]/, /\d/, /\d/, ')', ' ', /\d/, /\d/, /\d/, '-', /\d/, /\d/, '-', /\d/, /\d/];
        }
        return ['+', /[1-9]/, ' ', '(', /[1-9]/, /\d/, /\d/, ')', ' ', /\d/, /\d/, /\d/, '-', /\d/, /\d/, /\d/, '-', /\d/, /\d/];
    };
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var TextMaskConfig = /** @class */ (function () {
    function TextMaskConfig() {
    }
    return TextMaskConfig;
}());
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 * @return {?}
 */
function _isAndroid() {
    /** @type {?} */
    var userAgent = ɵgetDOM() ? ɵgetDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
var NgxPhoneMaskDirective = /** @class */ (function () {
    function NgxPhoneMaskDirective(_renderer, _elementRef, _compositionMode) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.clean = true;
        this.maxNumberLength = 13;
        /**
         * Whether the user is creating a composition string (IME events).
         */
        this._composing = false;
        this.onChange = function (_) {
        };
        this.onTouched = function () {
        };
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    /**
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    };
    /**
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.onTouched();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        /** @type {?} */
        var normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype._handleInput = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                if (this.clean) {
                    this.onChange(clean(value));
                }
                else {
                    this.onChange(value);
                }
            }
        }
    };
    /**
     * @param {?=} create
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype._setupMask = /**
     * @param {?=} create
     * @return {?}
     */
    function (create) {
        if (create === void 0) { create = false; }
        this.textMaskConfig = {
            mask: mask(this.maxNumberLength),
            guide: false,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    };
    /**
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype._compositionStart = /**
     * @return {?}
     */
    function () {
        this._composing = true;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NgxPhoneMaskDirective.prototype._compositionEnd = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    };
    NgxPhoneMaskDirective.decorators = [
        { type: Directive, args: [{
                    host: {
                        '(input)': '_handleInput($event.target.value)',
                        '(blur)': 'onTouched()',
                        '(compositionstart)': '_compositionStart()',
                        '(compositionend)': '_compositionEnd($event.target.value)'
                    },
                    selector: '[ngxPhoneMask]',
                    exportAs: 'ngxPhoneMask',
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(function () { return NgxPhoneMaskDirective; }),
                            multi: true
                        }]
                },] }
    ];
    /** @nocollapse */
    NgxPhoneMaskDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
    ]; };
    NgxPhoneMaskDirective.propDecorators = {
        clean: [{ type: Input }],
        maxNumberLength: [{ type: Input }],
        onBlur: [{ type: HostListener, args: ['blur',] }]
    };
    return NgxPhoneMaskDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPhoneMaskPipe = /** @class */ (function () {
    function NgxPhoneMaskPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    NgxPhoneMaskPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            return '';
        }
        return conformToMask(value, mask(), { guide: false }).conformedValue;
    };
    NgxPhoneMaskPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'ngxPhoneMask'
                },] }
    ];
    return NgxPhoneMaskPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var NgxPhoneMaskModule = /** @class */ (function () {
    function NgxPhoneMaskModule() {
    }
    NgxPhoneMaskModule.decorators = [
        { type: NgModule, args: [{
                    imports: [TextMaskModule],
                    declarations: [
                        NgxPhoneMaskDirective,
                        NgxPhoneMaskPipe
                    ],
                    exports: [
                        NgxPhoneMaskDirective,
                        NgxPhoneMaskPipe
                    ]
                },] }
    ];
    return NgxPhoneMaskModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TextMaskConfig, NgxPhoneMaskDirective, NgxPhoneMaskModule, NgxPhoneMaskPipe as ɵa };

//# sourceMappingURL=ngx-phone-mask.js.map