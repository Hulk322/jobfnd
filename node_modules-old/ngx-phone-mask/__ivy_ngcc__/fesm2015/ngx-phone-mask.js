import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { ɵgetDOM } from '@angular/platform-browser';
import { createTextMaskInputElement } from 'text-mask-core/dist/textMaskCore';
import { Directive, ElementRef, forwardRef, HostListener, Inject, Input, Optional, Renderer2, Pipe, NgModule } from '@angular/core';
import { conformToMask, TextMaskModule } from 'angular2-text-mask';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
import * as ɵngcc0 from '@angular/core';
const clean = (number) => {
    return number
        .toString()
        .replace(/[^\d\^\+]/gm, '');
};
/** @type {?} */
const mask = (maxLength = 13) => (rawValue) => {
    if (clean(rawValue).length <= 12 || maxLength === 12) {
        return ['+', /[1-9]/, ' ', '(', /[1-9]/, /\d/, /\d/, ')', ' ', /\d/, /\d/, /\d/, '-', /\d/, /\d/, '-', /\d/, /\d/];
    }
    return ['+', /[1-9]/, ' ', '(', /[1-9]/, /\d/, /\d/, ')', ' ', /\d/, /\d/, /\d/, '-', /\d/, /\d/, /\d/, '-', /\d/, /\d/];
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextMaskConfig {
}
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 * @return {?}
 */
function _isAndroid() {
    /** @type {?} */
    const userAgent = ɵgetDOM() ? ɵgetDOM().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
class NgxPhoneMaskDirective {
    /**
     * @param {?} _renderer
     * @param {?} _elementRef
     * @param {?} _compositionMode
     */
    constructor(_renderer, _elementRef, _compositionMode) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._compositionMode = _compositionMode;
        this.clean = true;
        this.maxNumberLength = 13;
        /**
         * Whether the user is creating a composition string (IME events).
         */
        this._composing = false;
        this.onChange = (_) => {
        };
        this.onTouched = () => {
        };
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this._setupMask(true);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(this.inputElement.value);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouched();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this._setupMask();
        // set the initial value for cases where the mask is disabled
        /** @type {?} */
        const normalizedValue = value == null ? '' : value;
        this._renderer.setProperty(this.inputElement, 'value', normalizedValue);
        if (this.textMaskInputElement !== undefined) {
            this.textMaskInputElement.update(value);
        }
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this._setupMask();
            if (this.textMaskInputElement !== undefined) {
                this.textMaskInputElement.update(value);
                // get the updated value
                value = this.inputElement.value;
                if (this.clean) {
                    this.onChange(clean(value));
                }
                else {
                    this.onChange(value);
                }
            }
        }
    }
    /**
     * @param {?=} create
     * @return {?}
     */
    _setupMask(create = false) {
        this.textMaskConfig = {
            mask: mask(this.maxNumberLength),
            guide: false,
            placeholderChar: '_',
            pipe: undefined,
            keepCharPositions: false,
        };
        if (!this.inputElement) {
            if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {
                // `textMask` directive is used directly on an input element
                this.inputElement = this._elementRef.nativeElement;
            }
            else {
                // `textMask` directive is used on an abstracted input element, `md-input-container`, etc
                this.inputElement = this._elementRef.nativeElement.getElementsByTagName('INPUT')[0];
            }
        }
        if (this.inputElement && create) {
            this.textMaskInputElement = createTextMaskInputElement(Object.assign({ inputElement: this.inputElement }, this.textMaskConfig));
        }
    }
    /**
     * @return {?}
     */
    _compositionStart() {
        this._composing = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
}
NgxPhoneMaskDirective.ɵfac = function NgxPhoneMaskDirective_Factory(t) { return new (t || NgxPhoneMaskDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(COMPOSITION_BUFFER_MODE, 8)); };
NgxPhoneMaskDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NgxPhoneMaskDirective, selectors: [["", "ngxPhoneMask", ""]], hostBindings: function NgxPhoneMaskDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function NgxPhoneMaskDirective_input_HostBindingHandler($event) { return ctx._handleInput($event.target.value); })("blur", function NgxPhoneMaskDirective_blur_HostBindingHandler() { return ctx.onBlur(); })("compositionstart", function NgxPhoneMaskDirective_compositionstart_HostBindingHandler() { return ctx._compositionStart(); })("compositionend", function NgxPhoneMaskDirective_compositionend_HostBindingHandler($event) { return ctx._compositionEnd($event.target.value); });
    } }, inputs: { clean: "clean", maxNumberLength: "maxNumberLength" }, exportAs: ["ngxPhoneMask"], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NgxPhoneMaskDirective),
                multi: true
            }]), ɵngcc0.ɵɵNgOnChangesFeature] });
/** @nocollapse */
NgxPhoneMaskDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: Boolean, decorators: [{ type: Optional }, { type: Inject, args: [COMPOSITION_BUFFER_MODE,] }] }
];
NgxPhoneMaskDirective.propDecorators = {
    clean: [{ type: Input }],
    maxNumberLength: [{ type: Input }],
    onBlur: [{ type: HostListener, args: ['blur',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPhoneMaskDirective, [{
        type: Directive,
        args: [{
                host: {
                    '(input)': '_handleInput($event.target.value)',
                    '(blur)': 'onTouched()',
                    '(compositionstart)': '_compositionStart()',
                    '(compositionend)': '_compositionEnd($event.target.value)'
                },
                selector: '[ngxPhoneMask]',
                exportAs: 'ngxPhoneMask',
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NgxPhoneMaskDirective),
                        multi: true
                    }]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: Boolean, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [COMPOSITION_BUFFER_MODE]
            }] }]; }, { clean: [{
            type: Input
        }], maxNumberLength: [{
            type: Input
        }], 
    /**
     * @return {?}
     */
    onBlur: [{
            type: HostListener,
            args: ['blur']
        }] }); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPhoneMaskPipe {
    /**
     * @param {?} value
     * @return {?}
     */
    transform(value) {
        if (!value) {
            return '';
        }
        return conformToMask(value, mask(), { guide: false }).conformedValue;
    }
}
NgxPhoneMaskPipe.ɵfac = function NgxPhoneMaskPipe_Factory(t) { return new (t || NgxPhoneMaskPipe)(); };
NgxPhoneMaskPipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "ngxPhoneMask", type: NgxPhoneMaskPipe, pure: true });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPhoneMaskPipe, [{
        type: Pipe,
        args: [{
                name: 'ngxPhoneMask'
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPhoneMaskModule {
}
NgxPhoneMaskModule.ɵfac = function NgxPhoneMaskModule_Factory(t) { return new (t || NgxPhoneMaskModule)(); };
NgxPhoneMaskModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxPhoneMaskModule });
NgxPhoneMaskModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ imports: [[TextMaskModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxPhoneMaskModule, { declarations: function () { return [NgxPhoneMaskDirective, NgxPhoneMaskPipe]; }, imports: function () { return [TextMaskModule]; }, exports: function () { return [NgxPhoneMaskDirective, NgxPhoneMaskPipe]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NgxPhoneMaskModule, [{
        type: NgModule,
        args: [{
                imports: [TextMaskModule],
                declarations: [
                    NgxPhoneMaskDirective,
                    NgxPhoneMaskPipe
                ],
                exports: [
                    NgxPhoneMaskDirective,
                    NgxPhoneMaskPipe
                ]
            }]
    }], null, null); })();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TextMaskConfig, NgxPhoneMaskDirective, NgxPhoneMaskModule, NgxPhoneMaskPipe as ɵa };

//# sourceMappingURL=ngx-phone-mask.js.map