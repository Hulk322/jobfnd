{"ast":null,"code":"import _classCallCheck from \"/home/ubuntu/job_board_fnd/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ubuntu/job_board_fnd/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\r\n * Sticky Sidebar JavaScript Plugin.\r\n * @version 3.3.1\r\n * @author Ahmed Bouhuolia <a.bouhuolia@gmail.com>\r\n * @license The MIT License (MIT)\r\n */\nvar StickySidebar = function () {\n  // ---------------------------------\n  // # Define Constants\n  // ---------------------------------\n  //\n  var EVENT_KEY = '.stickySidebar';\n  var VERSION = '3.3.1';\n  var DEFAULTS = {\n    /**\r\n     * Additional top spacing of the element when it becomes sticky.\r\n     * @type {Numeric|Function}\r\n     */\n    topSpacing: 0,\n\n    /**\r\n     * Additional bottom spacing of the element when it becomes sticky.\r\n     * @type {Numeric|Function}\r\n     */\n    bottomSpacing: 0,\n\n    /**\r\n     * Container sidebar selector to know what the beginning and end of sticky element.\r\n     * @type {String|False}\r\n     */\n    containerSelector: false,\n\n    /**\r\n     * Inner wrapper selector.\r\n     * @type {String}\r\n     */\n    innerWrapperSelector: '.inner-wrapper-sticky',\n\n    /**\r\n     * The name of CSS class to apply to elements when they have become stuck.\r\n     * @type {String|False}\r\n     */\n    stickyClass: 'is-affixed',\n\n    /**\r\n     * Detect when sidebar and its container change height so re-calculate their dimensions.\r\n     * @type {Boolean}\r\n     */\n    resizeSensor: true,\n\n    /**\r\n     * The sidebar returns to its normal position if its width below this value.\r\n     * @type {Numeric}\r\n     */\n    minWidth: false\n  }; // ---------------------------------\n  // # Class Definition\n  // ---------------------------------\n  //\n\n  /**\r\n   * Sticky Sidebar Class.\r\n   * @public\r\n   */\n\n  var StickySidebar = /*#__PURE__*/function () {\n    /**\r\n     * Sticky Sidebar Constructor.\r\n     * @constructor\r\n     * @param {HTMLElement|String} sidebar - The sidebar element or sidebar selector.\r\n     * @param {Object} options - The options of sticky sidebar.\r\n     */\n    function StickySidebar(sidebar) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, StickySidebar);\n\n      this.options = StickySidebar.extend(DEFAULTS, options); // Sidebar element query if there's no one, throw error.\n\n      this.sidebar = 'string' === typeof sidebar ? document.querySelector(sidebar) : sidebar;\n      if ('undefined' === typeof this.sidebar) throw new Error(\"There is no specific sidebar element.\");\n      this.sidebarInner = false;\n      this.container = this.sidebar.parentElement; // Current Affix Type of sidebar element.\n\n      this.affixedType = 'STATIC';\n      this.direction = 'down';\n      this.support = {\n        transform: false,\n        transform3d: false\n      };\n      this._initialized = false;\n      this._reStyle = false;\n      this._breakpoint = false;\n      this._resizeListeners = []; // Dimensions of sidebar, container and screen viewport.\n\n      this.dimensions = {\n        translateY: 0,\n        topSpacing: 0,\n        lastTopSpacing: 0,\n        bottomSpacing: 0,\n        lastBottomSpacing: 0,\n        sidebarHeight: 0,\n        sidebarWidth: 0,\n        containerTop: 0,\n        containerHeight: 0,\n        viewportHeight: 0,\n        viewportTop: 0,\n        lastViewportTop: 0\n      }; // Bind event handlers for referencability.\n\n      ['handleEvent'].forEach(function (method) {\n        _this[method] = _this[method].bind(_this);\n      }); // Initialize sticky sidebar for first time.\n\n      this.initialize();\n    }\n    /**\r\n     * Initializes the sticky sidebar by adding inner wrapper, define its container, \r\n     * min-width breakpoint, calculating dimensions, adding helper classes and inline style.\r\n     * @private\r\n     */\n\n\n    _createClass(StickySidebar, [{\n      key: \"initialize\",\n      value: function initialize() {\n        var _this2 = this;\n\n        this._setSupportFeatures(); // Get sticky sidebar inner wrapper, if not found, will create one.\n\n\n        if (this.options.innerWrapperSelector) {\n          this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector);\n          if (null === this.sidebarInner) this.sidebarInner = false;\n        }\n\n        if (!this.sidebarInner) {\n          var wrapper = document.createElement('div');\n          wrapper.setAttribute('class', 'inner-wrapper-sticky');\n          this.sidebar.appendChild(wrapper);\n\n          while (this.sidebar.firstChild != wrapper) wrapper.appendChild(this.sidebar.firstChild);\n\n          this.sidebarInner = this.sidebar.querySelector('.inner-wrapper-sticky');\n        } // Container wrapper of the sidebar.\n\n\n        if (this.options.containerSelector) {\n          var containers = document.querySelectorAll(this.options.containerSelector);\n          containers = Array.prototype.slice.call(containers);\n          containers.forEach(function (container, item) {\n            if (!container.contains(_this2.sidebar)) return;\n            _this2.container = container;\n          });\n          if (!containers.length) throw new Error(\"The container does not contains on the sidebar.\");\n        } // If top/bottom spacing is not function parse value to integer.\n\n\n        if ('function' !== typeof this.options.topSpacing) this.options.topSpacing = parseInt(this.options.topSpacing) || 0;\n        if ('function' !== typeof this.options.bottomSpacing) this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0; // Breakdown sticky sidebar if screen width below `options.minWidth`.\n\n        this._widthBreakpoint(); // Calculate dimensions of sidebar, container and viewport.\n\n\n        this.calcDimensions(); // Affix sidebar in proper position.\n\n        this.stickyPosition(); // Bind all events.\n\n        this.bindEvents(); // Inform other properties the sticky sidebar is initialized.\n\n        this._initialized = true;\n      }\n      /**\r\n       * Bind all events of sticky sidebar plugin.\r\n       * @protected\r\n       */\n\n    }, {\n      key: \"bindEvents\",\n      value: function bindEvents() {\n        window.addEventListener('resize', this, {\n          passive: true,\n          capture: false\n        });\n        window.addEventListener('scroll', this, {\n          passive: true,\n          capture: false\n        });\n        this.sidebar.addEventListener('update' + EVENT_KEY, this);\n\n        if (this.options.resizeSensor && 'undefined' !== typeof ResizeSensor) {\n          new ResizeSensor(this.sidebarInner, this.handleEvent);\n          new ResizeSensor(this.container, this.handleEvent);\n        }\n      }\n      /**\r\n       * Handles all events of the plugin.\r\n       * @param {Object} event - Event object passed from listener.\r\n       */\n\n    }, {\n      key: \"handleEvent\",\n      value: function handleEvent(event) {\n        this.updateSticky(event);\n      }\n      /**\r\n       * Calculates dimensions of sidebar, container and screen viewpoint\r\n       * @public\r\n       */\n\n    }, {\n      key: \"calcDimensions\",\n      value: function calcDimensions() {\n        if (this._breakpoint) return;\n        var dims = this.dimensions; // Container of sticky sidebar dimensions.\n\n        dims.containerTop = StickySidebar.offsetRelative(this.container).top;\n        dims.containerHeight = this.container.clientHeight;\n        dims.containerBottom = dims.containerTop + dims.containerHeight; // Sidebar dimensions.\n\n        dims.sidebarHeight = this.sidebarInner.offsetHeight;\n        dims.sidebarWidth = this.sidebar.offsetWidth; // Screen viewport dimensions.\n\n        dims.viewportHeight = window.innerHeight;\n\n        this._calcDimensionsWithScroll();\n      }\n      /**\r\n       * Some dimensions values need to be up-to-date when scrolling the page.\r\n       * @private\r\n       */\n\n    }, {\n      key: \"_calcDimensionsWithScroll\",\n      value: function _calcDimensionsWithScroll() {\n        var dims = this.dimensions;\n        dims.sidebarLeft = StickySidebar.offsetRelative(this.sidebar).left;\n        dims.viewportTop = document.documentElement.scrollTop || document.body.scrollTop;\n        dims.viewportBottom = dims.viewportTop + dims.viewportHeight;\n        dims.viewportLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        dims.topSpacing = this.options.topSpacing;\n        dims.bottomSpacing = this.options.bottomSpacing;\n        if ('function' === typeof dims.topSpacing) dims.topSpacing = parseInt(dims.topSpacing(this.sidebar)) || 0;\n        if ('function' === typeof dims.bottomSpacing) dims.bottomSpacing = parseInt(dims.bottomSpacing(this.sidebar)) || 0;\n\n        if ('VIEWPORT-TOP' === this.affixedType) {\n          // Adjust translate Y in the case decrease top spacing value.\n          if (dims.topSpacing < dims.lastTopSpacing) {\n            dims.translateY += dims.lastTopSpacing - dims.topSpacing;\n            this._reStyle = true;\n          }\n        } else if ('VIEWPORT-BOTTOM' === this.affixedType) {\n          // Adjust translate Y in the case decrease bottom spacing value.\n          if (dims.bottomSpacing < dims.lastBottomSpacing) {\n            dims.translateY += dims.lastBottomSpacing - dims.bottomSpacing;\n            this._reStyle = true;\n          }\n        }\n\n        dims.lastTopSpacing = dims.topSpacing;\n        dims.lastBottomSpacing = dims.bottomSpacing;\n      }\n      /**\r\n       * Determine whether the sidebar is bigger than viewport.\r\n       * @public\r\n       * @return {Boolean}\r\n       */\n\n    }, {\n      key: \"isSidebarFitsViewport\",\n      value: function isSidebarFitsViewport() {\n        return this.dimensions.sidebarHeight < this.dimensions.viewportHeight;\n      }\n      /**\r\n       * Observe browser scrolling direction top and down.\r\n       */\n\n    }, {\n      key: \"observeScrollDir\",\n      value: function observeScrollDir() {\n        var dims = this.dimensions;\n        if (dims.lastViewportTop === dims.viewportTop) return;\n        var furthest = 'down' === this.direction ? Math.min : Math.max; // If the browser is scrolling not in the same direction.\n\n        if (dims.viewportTop === furthest(dims.viewportTop, dims.lastViewportTop)) this.direction = 'down' === this.direction ? 'up' : 'down';\n      }\n      /**\r\n       * Gets affix type of sidebar according to current scrollTop and scrollLeft.\r\n       * Holds all logical affix of the sidebar when scrolling up and down and when sidebar \r\n       * is bigger than viewport and vice versa.\r\n       * @public\r\n       * @return {String|False} - Proper affix type.\r\n       */\n\n    }, {\n      key: \"getAffixType\",\n      value: function getAffixType() {\n        var dims = this.dimensions,\n            affixType = false;\n\n        this._calcDimensionsWithScroll();\n\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\n        var colliderTop = dims.viewportTop + dims.topSpacing;\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing; // When browser is scrolling top.\n\n        if ('up' === this.direction) {\n          if (colliderTop <= dims.containerTop) {\n            dims.translateY = 0;\n            affixType = 'STATIC';\n          } else if (colliderTop <= dims.translateY + dims.containerTop) {\n            dims.translateY = colliderTop - dims.containerTop;\n            affixType = 'VIEWPORT-TOP';\n          } else if (!this.isSidebarFitsViewport() && dims.containerTop <= colliderTop) {\n            affixType = 'VIEWPORT-UNBOTTOM';\n          } // When browser is scrolling up.\n\n        } else {\n          // When sidebar element is not bigger than screen viewport.\n          if (this.isSidebarFitsViewport()) {\n            if (dims.sidebarHeight + colliderTop >= dims.containerBottom) {\n              dims.translateY = dims.containerBottom - sidebarBottom;\n              affixType = 'CONTAINER-BOTTOM';\n            } else if (colliderTop >= dims.containerTop) {\n              dims.translateY = colliderTop - dims.containerTop;\n              affixType = 'VIEWPORT-TOP';\n            } // When sidebar element is bigger than screen viewport.\n\n          } else {\n            if (dims.containerBottom <= colliderBottom) {\n              dims.translateY = dims.containerBottom - sidebarBottom;\n              affixType = 'CONTAINER-BOTTOM';\n            } else if (sidebarBottom + dims.translateY <= colliderBottom) {\n              dims.translateY = colliderBottom - sidebarBottom;\n              affixType = 'VIEWPORT-BOTTOM';\n            } else if (dims.containerTop + dims.translateY <= colliderTop) {\n              affixType = 'VIEWPORT-UNBOTTOM';\n            }\n          }\n        } // Make sure the translate Y is not bigger than container height.\n\n\n        dims.translateY = Math.max(0, dims.translateY);\n        dims.translateY = Math.min(dims.containerHeight, dims.translateY);\n        dims.lastViewportTop = dims.viewportTop;\n        return affixType;\n      }\n      /**\r\n       * Gets inline style of sticky sidebar wrapper and inner wrapper according \r\n       * to its affix type.\r\n       * @private\r\n       * @param {String} affixType - Affix type of sticky sidebar.\r\n       * @return {Object}\r\n       */\n\n    }, {\n      key: \"_getStyle\",\n      value: function _getStyle(affixType) {\n        if ('undefined' === typeof affixType) return;\n        var style = {\n          inner: {},\n          outer: {}\n        };\n        var dims = this.dimensions;\n\n        switch (affixType) {\n          case 'VIEWPORT-TOP':\n            style.inner = {\n              position: 'fixed',\n              top: dims.topSpacing,\n              left: dims.sidebarLeft - dims.viewportLeft,\n              width: dims.sidebarWidth\n            };\n            break;\n\n          case 'VIEWPORT-BOTTOM':\n            style.inner = {\n              position: 'fixed',\n              top: 'auto',\n              left: dims.sidebarLeft,\n              bottom: dims.bottomSpacing,\n              width: dims.sidebarWidth\n            };\n            break;\n\n          case 'CONTAINER-BOTTOM':\n          case 'VIEWPORT-UNBOTTOM':\n            var translate = this._getTranslate(0, dims.translateY + 'px');\n\n            if (translate) style.inner = {\n              transform: translate\n            };else style.inner = {\n              position: 'absolute',\n              top: dims.translateY,\n              width: dims.sidebarWidth\n            };\n            break;\n        }\n\n        switch (affixType) {\n          case 'VIEWPORT-TOP':\n          case 'VIEWPORT-BOTTOM':\n          case 'VIEWPORT-UNBOTTOM':\n          case 'CONTAINER-BOTTOM':\n            style.outer = {\n              height: dims.sidebarHeight,\n              position: 'relative'\n            };\n            break;\n        }\n\n        style.outer = StickySidebar.extend({\n          height: '',\n          position: ''\n        }, style.outer);\n        style.inner = StickySidebar.extend({\n          position: 'relative',\n          top: '',\n          left: '',\n          bottom: '',\n          width: '',\n          transform: this._getTranslate()\n        }, style.inner);\n        return style;\n      }\n      /**\r\n       * Cause the sidebar to be sticky according to affix type by adding inline\r\n       * style, adding helper class and trigger events.\r\n       * @function\r\n       * @protected\r\n       * @param {string} force - Update sticky sidebar position by force.\r\n       */\n\n    }, {\n      key: \"stickyPosition\",\n      value: function stickyPosition(force) {\n        if (this._breakpoint) return;\n        force = this._reStyle || force || false;\n        var offsetTop = this.options.topSpacing;\n        var offsetBottom = this.options.bottomSpacing;\n        var affixType = this.getAffixType();\n\n        var style = this._getStyle(affixType);\n\n        if ((this.affixedType != affixType || force) && affixType) {\n          var affixEvent = 'affix.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\n          StickySidebar.eventTrigger(this.sidebar, affixEvent);\n          if ('STATIC' === affixType) StickySidebar.removeClass(this.sidebar, this.options.stickyClass);else StickySidebar.addClass(this.sidebar, this.options.stickyClass);\n\n          for (var key in style.outer) {\n            var _unit = 'number' === typeof style.outer[key] ? 'px' : '';\n\n            this.sidebar.style[key] = style.outer[key];\n          }\n\n          for (var _key in style.inner) {\n            var _unit2 = 'number' === typeof style.inner[_key] ? 'px' : '';\n\n            this.sidebarInner.style[_key] = style.inner[_key] + _unit2;\n          }\n\n          var affixedEvent = 'affixed.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\n          StickySidebar.eventTrigger(this.sidebar, affixedEvent);\n        } else {\n          if (this._initialized) this.sidebarInner.style.left = style.inner.left;\n        }\n\n        this.affixedType = affixType;\n      }\n      /**\r\n       * Breakdown sticky sidebar when window width is below `options.minWidth` value.\r\n       * @protected\r\n       */\n\n    }, {\n      key: \"_widthBreakpoint\",\n      value: function _widthBreakpoint() {\n        if (window.innerWidth <= this.options.minWidth) {\n          this._breakpoint = true;\n          this.affixedType = 'STATIC';\n          this.sidebar.removeAttribute('style');\n          StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\n          this.sidebarInner.removeAttribute('style');\n        } else {\n          this._breakpoint = false;\n        }\n      }\n      /**\r\n       * Switches between functions stack for each event type, if there's no \r\n       * event, it will re-initialize sticky sidebar.\r\n       * @public\r\n       */\n\n    }, {\n      key: \"updateSticky\",\n      value: function updateSticky() {\n        var _this3 = this;\n\n        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        if (this._running) return;\n        this._running = true;\n\n        (function (eventType) {\n          requestAnimationFrame(function () {\n            switch (eventType) {\n              // When browser is scrolling and re-calculate just dimensions\n              // within scroll. \n              case 'scroll':\n                _this3._calcDimensionsWithScroll();\n\n                _this3.observeScrollDir();\n\n                _this3.stickyPosition();\n\n                break;\n              // When browser is resizing or there's no event, observe width\n              // breakpoint and re-calculate dimensions.\n\n              case 'resize':\n              default:\n                _this3._widthBreakpoint();\n\n                _this3.calcDimensions();\n\n                _this3.stickyPosition(true);\n\n                break;\n            }\n\n            _this3._running = false;\n          });\n        })(event.type);\n      }\n      /**\r\n       * Set browser support features to the public property.\r\n       * @private\r\n       */\n\n    }, {\n      key: \"_setSupportFeatures\",\n      value: function _setSupportFeatures() {\n        var support = this.support;\n        support.transform = StickySidebar.supportTransform();\n        support.transform3d = StickySidebar.supportTransform(true);\n      }\n      /**\r\n       * Get translate value, if the browser supports transfrom3d, it will adopt it.\r\n       * and the same with translate. if browser doesn't support both return false.\r\n       * @param {Number} y - Value of Y-axis.\r\n       * @param {Number} x - Value of X-axis.\r\n       * @param {Number} z - Value of Z-axis.\r\n       * @return {String|False}\r\n       */\n\n    }, {\n      key: \"_getTranslate\",\n      value: function _getTranslate() {\n        var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        if (this.support.transform3d) return 'translate3d(' + y + ', ' + x + ', ' + z + ')';else if (this.support.translate) return 'translate(' + y + ', ' + x + ')';else return false;\n      }\n      /**\r\n       * Destroy sticky sidebar plugin.\r\n       * @public\r\n       */\n\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        window.removeEventListener('resize', this, {\n          caption: false\n        });\n        window.removeEventListener('scroll', this, {\n          caption: false\n        });\n        this.sidebar.classList.remove(this.options.stickyClass);\n        this.sidebar.style.minHeight = '';\n        this.sidebar.removeEventListener('update' + EVENT_KEY, this);\n        var styleReset = {\n          inner: {},\n          outer: {}\n        };\n        styleReset.inner = {\n          position: '',\n          top: '',\n          left: '',\n          bottom: '',\n          width: '',\n          transform: ''\n        };\n        styleReset.outer = {\n          height: '',\n          position: ''\n        };\n\n        for (var key in styleReset.outer) this.sidebar.style[key] = styleReset.outer[key];\n\n        for (var _key2 in styleReset.inner) this.sidebarInner.style[_key2] = styleReset.inner[_key2];\n\n        if (this.options.resizeSensor && 'undefined' !== typeof ResizeSensor) {\n          ResizeSensor.detach(this.sidebarInner, this.handleEvent);\n          ResizeSensor.detach(this.container, this.handleEvent);\n        }\n      }\n      /**\r\n       * Determine if the browser supports CSS transform feature.\r\n       * @function\r\n       * @static\r\n       * @param {Boolean} transform3d - Detect transform with translate3d.\r\n       * @return {String}\r\n       */\n\n    }], [{\n      key: \"supportTransform\",\n      value: function supportTransform(transform3d) {\n        var result = false,\n            property = transform3d ? 'perspective' : 'transform',\n            upper = property.charAt(0).toUpperCase() + property.slice(1),\n            prefixes = ['Webkit', 'Moz', 'O', 'ms'],\n            support = document.createElement('support'),\n            style = support.style;\n        (property + ' ' + prefixes.join(upper + ' ') + upper).split(' ').forEach(function (property, i) {\n          if (style[property] !== undefined) {\n            result = property;\n            return false;\n          }\n        });\n        return result;\n      }\n      /**\r\n       * Trigger custom event.\r\n       * @static\r\n       * @param {DOMObject} element - Target element on the DOM.\r\n       * @param {String} eventName - Event name.\r\n       * @param {Object} data - \r\n       */\n\n    }, {\n      key: \"eventTrigger\",\n      value: function eventTrigger(element, eventName, data) {\n        try {\n          var event = new CustomEvent(eventName, {\n            detail: data\n          });\n        } catch (e) {\n          var event = document.createEvent('CustomEvent');\n          event.initCustomEvent(eventName, true, true, data);\n        }\n\n        element.dispatchEvent(event);\n      }\n      /**\r\n       * Extend options object with defaults.\r\n       * @function\r\n       * @static\r\n       */\n\n    }, {\n      key: \"extend\",\n      value: function extend(defaults, options) {\n        var results = {};\n\n        for (var key in defaults) {\n          if ('undefined' !== typeof options[key]) results[key] = options[key];else results[key] = defaults[key];\n        }\n\n        return results;\n      }\n      /**\r\n       * Get current coordinates left and top of specific element.\r\n       * @static\r\n       */\n\n    }, {\n      key: \"offsetRelative\",\n      value: function offsetRelative(element) {\n        var result = {\n          left: 0,\n          top: 0\n        };\n\n        do {\n          var offsetTop = element.offsetTop;\n          var offsetLeft = element.offsetLeft;\n          if (!isNaN(offsetTop)) result.top += offsetTop;\n          if (!isNaN(offsetLeft)) result.left += offsetLeft;\n          element = 'BODY' === element.tagName ? element.parentElement : element.offsetParent;\n        } while (element);\n\n        return result;\n      }\n      /**\r\n       * Add specific class name to specific element.\r\n       * @static \r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\n\n    }, {\n      key: \"addClass\",\n      value: function addClass(element, className) {\n        if (!StickySidebar.hasClass(element, className)) {\n          if (element.classList) element.classList.add(className);else element.className += ' ' + className;\n        }\n      }\n      /**\r\n       * Remove specific class name to specific element\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\n\n    }, {\n      key: \"removeClass\",\n      value: function removeClass(element, className) {\n        if (StickySidebar.hasClass(element, className)) {\n          if (element.classList) element.classList.remove(className);else element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n      }\n      /**\r\n       * Determine weather the element has specific class name.\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\n\n    }, {\n      key: \"hasClass\",\n      value: function hasClass(element, className) {\n        if (element.classList) return element.classList.contains(className);else return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n      }\n    }]);\n\n    return StickySidebar;\n  }();\n\n  return StickySidebar;\n}();\n\nexport default StickySidebar; // Global\n// -------------------------\n\nwindow.StickySidebar = StickySidebar;","map":{"version":3,"sources":["/home/ubuntu/job_board_fnd/node_modules/sticky-sidebar/src/sticky-sidebar.js"],"names":["StickySidebar","EVENT_KEY","VERSION","DEFAULTS","topSpacing","bottomSpacing","containerSelector","innerWrapperSelector","stickyClass","resizeSensor","minWidth","sidebar","options","extend","document","querySelector","Error","sidebarInner","container","parentElement","affixedType","direction","support","transform","transform3d","_initialized","_reStyle","_breakpoint","_resizeListeners","dimensions","translateY","lastTopSpacing","lastBottomSpacing","sidebarHeight","sidebarWidth","containerTop","containerHeight","viewportHeight","viewportTop","lastViewportTop","forEach","method","bind","initialize","_setSupportFeatures","wrapper","createElement","setAttribute","appendChild","firstChild","containers","querySelectorAll","Array","prototype","slice","call","item","contains","length","parseInt","_widthBreakpoint","calcDimensions","stickyPosition","bindEvents","window","addEventListener","passive","capture","ResizeSensor","handleEvent","event","updateSticky","dims","offsetRelative","top","clientHeight","containerBottom","offsetHeight","offsetWidth","innerHeight","_calcDimensionsWithScroll","sidebarLeft","left","documentElement","scrollTop","body","viewportBottom","viewportLeft","scrollLeft","furthest","Math","min","max","affixType","sidebarBottom","colliderTop","colliderBottom","isSidebarFitsViewport","style","inner","outer","position","width","bottom","translate","_getTranslate","height","force","offsetTop","offsetBottom","getAffixType","_getStyle","affixEvent","toLowerCase","replace","eventTrigger","removeClass","addClass","key","_unit","affixedEvent","innerWidth","removeAttribute","_running","eventType","requestAnimationFrame","observeScrollDir","type","supportTransform","y","x","z","removeEventListener","caption","classList","remove","minHeight","styleReset","detach","result","property","upper","charAt","toUpperCase","prefixes","join","split","i","undefined","element","eventName","data","CustomEvent","detail","e","createEvent","initCustomEvent","dispatchEvent","defaults","results","offsetLeft","isNaN","tagName","offsetParent","className","hasClass","add","RegExp","test"],"mappings":"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","sourcesContent":["/**\r\n * Sticky Sidebar JavaScript Plugin.\r\n * @version 3.3.1\r\n * @author Ahmed Bouhuolia <a.bouhuolia@gmail.com>\r\n * @license The MIT License (MIT)\r\n */\r\nconst StickySidebar = (() => {\r\n  \r\n    // ---------------------------------\r\n    // # Define Constants\r\n    // ---------------------------------\r\n    //\r\n    const EVENT_KEY = '.stickySidebar';\r\n    const VERSION   = '3.3.1';\r\n  \r\n    const DEFAULTS = {\r\n      \r\n      /**\r\n       * Additional top spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      topSpacing: 0,\r\n  \r\n      /**\r\n       * Additional bottom spacing of the element when it becomes sticky.\r\n       * @type {Numeric|Function}\r\n       */\r\n      bottomSpacing: 0,\r\n  \r\n      /**\r\n       * Container sidebar selector to know what the beginning and end of sticky element.\r\n       * @type {String|False}\r\n       */\r\n      containerSelector: false,\r\n  \r\n      /**\r\n       * Inner wrapper selector.\r\n       * @type {String}\r\n       */\r\n      innerWrapperSelector: '.inner-wrapper-sticky',\r\n  \r\n      /**\r\n       * The name of CSS class to apply to elements when they have become stuck.\r\n       * @type {String|False}\r\n       */\r\n      stickyClass: 'is-affixed',\r\n  \r\n      /**\r\n       * Detect when sidebar and its container change height so re-calculate their dimensions.\r\n       * @type {Boolean}\r\n       */\r\n      resizeSensor: true,\r\n  \r\n      /**\r\n       * The sidebar returns to its normal position if its width below this value.\r\n       * @type {Numeric}\r\n       */\r\n      minWidth: false\r\n    };\r\n  \r\n    // ---------------------------------\r\n    // # Class Definition\r\n    // ---------------------------------\r\n    //\r\n    /**\r\n     * Sticky Sidebar Class.\r\n     * @public\r\n     */\r\n    class StickySidebar{\r\n  \r\n      /**\r\n       * Sticky Sidebar Constructor.\r\n       * @constructor\r\n       * @param {HTMLElement|String} sidebar - The sidebar element or sidebar selector.\r\n       * @param {Object} options - The options of sticky sidebar.\r\n       */\r\n      constructor(sidebar, options = {}){\r\n        this.options = StickySidebar.extend(DEFAULTS, options);\r\n  \r\n        // Sidebar element query if there's no one, throw error.\r\n        this.sidebar = ('string' === typeof sidebar ) ? document.querySelector(sidebar) : sidebar;\r\n        if( 'undefined' === typeof this.sidebar )\r\n          throw new Error(\"There is no specific sidebar element.\");\r\n  \r\n        this.sidebarInner = false;\r\n        this.container = this.sidebar.parentElement;\r\n  \r\n        // Current Affix Type of sidebar element.\r\n        this.affixedType = 'STATIC';\r\n        this.direction = 'down';\r\n        this.support = {\r\n          transform:   false,\r\n          transform3d: false\r\n        };\r\n  \r\n        this._initialized = false;\r\n        this._reStyle = false;\r\n        this._breakpoint = false;\r\n        this._resizeListeners = [];\r\n        \r\n        // Dimensions of sidebar, container and screen viewport.\r\n        this.dimensions = {\r\n          translateY: 0,\r\n          topSpacing: 0,\r\n          lastTopSpacing: 0,\r\n          bottomSpacing: 0,\r\n          lastBottomSpacing: 0,\r\n          sidebarHeight: 0,\r\n          sidebarWidth: 0,\r\n          containerTop: 0,\r\n          containerHeight: 0,\r\n          viewportHeight: 0,\r\n          viewportTop: 0, \r\n          lastViewportTop: 0,\r\n        };\r\n  \r\n        // Bind event handlers for referencability.\r\n        ['handleEvent'].forEach( (method) => {\r\n          this[method] = this[method].bind(this);\r\n        });\r\n  \r\n        // Initialize sticky sidebar for first time.\r\n        this.initialize();\r\n      }\r\n  \r\n      /**\r\n       * Initializes the sticky sidebar by adding inner wrapper, define its container, \r\n       * min-width breakpoint, calculating dimensions, adding helper classes and inline style.\r\n       * @private\r\n       */\r\n      initialize(){\r\n        this._setSupportFeatures();\r\n  \r\n        // Get sticky sidebar inner wrapper, if not found, will create one.\r\n        if( this.options.innerWrapperSelector ){\r\n          this.sidebarInner = this.sidebar.querySelector(this.options.innerWrapperSelector);\r\n  \r\n          if( null === this.sidebarInner )\r\n            this.sidebarInner = false;\r\n        }\r\n        \r\n        if( ! this.sidebarInner ){\r\n          let wrapper = document.createElement('div');\r\n          wrapper.setAttribute('class', 'inner-wrapper-sticky');\r\n          this.sidebar.appendChild(wrapper);\r\n  \r\n          while( this.sidebar.firstChild != wrapper )\r\n            wrapper.appendChild(this.sidebar.firstChild);\r\n  \r\n          this.sidebarInner = this.sidebar.querySelector('.inner-wrapper-sticky');\r\n        }\r\n  \r\n        // Container wrapper of the sidebar.\r\n        if( this.options.containerSelector ){\r\n          let containers = document.querySelectorAll(this.options.containerSelector);\r\n          containers = Array.prototype.slice.call(containers);\r\n  \r\n          containers.forEach((container, item) => {\r\n            if( ! container.contains(this.sidebar) ) return;\r\n            this.container = container;\r\n          });\r\n  \r\n          if( ! containers.length )\r\n            throw new Error(\"The container does not contains on the sidebar.\");\r\n        }\r\n        \r\n        // If top/bottom spacing is not function parse value to integer.\r\n        if( 'function' !== typeof this.options.topSpacing )\r\n          this.options.topSpacing = parseInt(this.options.topSpacing) || 0;\r\n  \r\n        if( 'function' !== typeof this.options.bottomSpacing )\r\n          this.options.bottomSpacing = parseInt(this.options.bottomSpacing) || 0;\r\n            \r\n        // Breakdown sticky sidebar if screen width below `options.minWidth`.\r\n        this._widthBreakpoint();\r\n  \r\n        // Calculate dimensions of sidebar, container and viewport.\r\n        this.calcDimensions();\r\n  \r\n        // Affix sidebar in proper position.\r\n        this.stickyPosition();\r\n  \r\n        // Bind all events.\r\n        this.bindEvents();\r\n        \r\n        // Inform other properties the sticky sidebar is initialized.\r\n        this._initialized = true;\r\n      }\r\n  \r\n      /**\r\n       * Bind all events of sticky sidebar plugin.\r\n       * @protected\r\n       */\r\n      bindEvents(){\r\n        window.addEventListener('resize', this, {passive: true, capture: false});\r\n        window.addEventListener('scroll', this, {passive: true, capture: false});\r\n  \r\n        this.sidebar.addEventListener('update' + EVENT_KEY, this);\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          new ResizeSensor(this.sidebarInner, this.handleEvent);\r\n          new ResizeSensor(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Handles all events of the plugin.\r\n       * @param {Object} event - Event object passed from listener.\r\n       */\r\n      handleEvent(event){\r\n        this.updateSticky(event);\r\n      }\r\n  \r\n      /**\r\n       * Calculates dimensions of sidebar, container and screen viewpoint\r\n       * @public\r\n       */\r\n      calcDimensions(){\r\n        if( this._breakpoint ) return;\r\n        var dims = this.dimensions;\r\n  \r\n        // Container of sticky sidebar dimensions.\r\n        dims.containerTop    = StickySidebar.offsetRelative(this.container).top;\r\n        dims.containerHeight = this.container.clientHeight;\r\n        dims.containerBottom = dims.containerTop + dims.containerHeight;\r\n  \r\n        // Sidebar dimensions.\r\n        dims.sidebarHeight = this.sidebarInner.offsetHeight;\r\n        dims.sidebarWidth  = this.sidebar.offsetWidth;\r\n        \r\n        // Screen viewport dimensions.\r\n        dims.viewportHeight = window.innerHeight;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n      }\r\n  \r\n      /**\r\n       * Some dimensions values need to be up-to-date when scrolling the page.\r\n       * @private\r\n       */\r\n      _calcDimensionsWithScroll(){\r\n        var dims = this.dimensions;\r\n  \r\n        dims.sidebarLeft = StickySidebar.offsetRelative(this.sidebar).left;\r\n  \r\n        dims.viewportTop    = document.documentElement.scrollTop || document.body.scrollTop;\r\n        dims.viewportBottom = dims.viewportTop + dims.viewportHeight;\r\n        dims.viewportLeft   = document.documentElement.scrollLeft || document.body.scrollLeft;\r\n  \r\n        dims.topSpacing    = this.options.topSpacing;\r\n        dims.bottomSpacing = this.options.bottomSpacing;\r\n  \r\n        if( 'function' === typeof dims.topSpacing )\r\n            dims.topSpacing = parseInt(dims.topSpacing(this.sidebar)) || 0;\r\n  \r\n        if( 'function' === typeof dims.bottomSpacing )\r\n            dims.bottomSpacing = parseInt(dims.bottomSpacing(this.sidebar)) || 0;\r\n        \r\n        if( 'VIEWPORT-TOP' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease top spacing value.\r\n          if( dims.topSpacing < dims.lastTopSpacing ){\r\n            dims.translateY += dims.lastTopSpacing - dims.topSpacing;\r\n            this._reStyle = true; \r\n          }\r\n        \r\n        } else if( 'VIEWPORT-BOTTOM' === this.affixedType ){\r\n          // Adjust translate Y in the case decrease bottom spacing value.\r\n          if( dims.bottomSpacing < dims.lastBottomSpacing ){\r\n            dims.translateY += dims.lastBottomSpacing - dims.bottomSpacing;\r\n            this._reStyle = true;\r\n          }\r\n        }\r\n        \r\n        dims.lastTopSpacing    = dims.topSpacing;\r\n        dims.lastBottomSpacing = dims.bottomSpacing;\r\n      }\r\n      \r\n      /**\r\n       * Determine whether the sidebar is bigger than viewport.\r\n       * @public\r\n       * @return {Boolean}\r\n       */\r\n      isSidebarFitsViewport(){\r\n        return this.dimensions.sidebarHeight < this.dimensions.viewportHeight;\r\n      }\r\n  \r\n      /**\r\n       * Observe browser scrolling direction top and down.\r\n       */\r\n      observeScrollDir(){\r\n        var dims = this.dimensions;\r\n        if( dims.lastViewportTop === dims.viewportTop ) return;\r\n  \r\n        var furthest = 'down' === this.direction ? Math.min : Math.max;\r\n        \r\n        // If the browser is scrolling not in the same direction.\r\n        if( dims.viewportTop === furthest(dims.viewportTop, dims.lastViewportTop) )\r\n          this.direction = 'down' === this.direction ?  'up' : 'down';\r\n      }\r\n  \r\n      /**\r\n       * Gets affix type of sidebar according to current scrollTop and scrollLeft.\r\n       * Holds all logical affix of the sidebar when scrolling up and down and when sidebar \r\n       * is bigger than viewport and vice versa.\r\n       * @public\r\n       * @return {String|False} - Proper affix type.\r\n       */\r\n      getAffixType(){\r\n        var dims = this.dimensions, affixType = false;\r\n  \r\n        this._calcDimensionsWithScroll();\r\n  \r\n        var sidebarBottom = dims.sidebarHeight + dims.containerTop;\r\n        var colliderTop = dims.viewportTop + dims.topSpacing;\r\n        var colliderBottom = dims.viewportBottom - dims.bottomSpacing;\r\n  \r\n        // When browser is scrolling top.\r\n        if( 'up' === this.direction ){\r\n          if( colliderTop <= dims.containerTop ){\r\n            dims.translateY = 0;\r\n            affixType = 'STATIC';\r\n  \r\n          } else if( colliderTop <= dims.translateY + dims.containerTop ){\r\n            dims.translateY = colliderTop - dims.containerTop;\r\n            affixType = 'VIEWPORT-TOP';\r\n  \r\n          } else if( ! this.isSidebarFitsViewport() && dims.containerTop <= colliderTop ){\r\n            affixType = 'VIEWPORT-UNBOTTOM';\r\n          }\r\n        // When browser is scrolling up.\r\n        } else {\r\n          // When sidebar element is not bigger than screen viewport.\r\n          if( this.isSidebarFitsViewport() ){\r\n  \r\n            if( dims.sidebarHeight + colliderTop >= dims.containerBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom;\r\n              affixType = 'CONTAINER-BOTTOM'; \r\n  \r\n            } else if( colliderTop >= dims.containerTop ){\r\n              dims.translateY = colliderTop - dims.containerTop;\r\n              affixType = 'VIEWPORT-TOP';\r\n            }\r\n          // When sidebar element is bigger than screen viewport.\r\n          } else {\r\n      \r\n            if( dims.containerBottom <= colliderBottom ){\r\n              dims.translateY = dims.containerBottom - sidebarBottom; \r\n              affixType = 'CONTAINER-BOTTOM';    \r\n  \r\n            } else if( sidebarBottom + dims.translateY <= colliderBottom ){\r\n              dims.translateY = colliderBottom - sidebarBottom;\r\n              affixType = 'VIEWPORT-BOTTOM';\r\n            \r\n            } else if( dims.containerTop + dims.translateY <= colliderTop ){\r\n              affixType = 'VIEWPORT-UNBOTTOM';\r\n            }\r\n          }\r\n        }\r\n  \r\n        // Make sure the translate Y is not bigger than container height.\r\n        dims.translateY = Math.max(0, dims.translateY);\r\n        dims.translateY = Math.min(dims.containerHeight, dims.translateY);\r\n  \r\n        dims.lastViewportTop = dims.viewportTop;\r\n        return affixType;\r\n      }\r\n  \r\n      /**\r\n       * Gets inline style of sticky sidebar wrapper and inner wrapper according \r\n       * to its affix type.\r\n       * @private\r\n       * @param {String} affixType - Affix type of sticky sidebar.\r\n       * @return {Object}\r\n       */\r\n      _getStyle(affixType){\r\n        if( 'undefined' === typeof affixType ) return;\r\n  \r\n        var style = {inner: {}, outer: {}};\r\n        var dims = this.dimensions;\r\n  \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n            style.inner = {position: 'fixed', top: dims.topSpacing,\r\n                  left: dims.sidebarLeft - dims.viewportLeft, width: dims.sidebarWidth};\r\n            break;\r\n          case 'VIEWPORT-BOTTOM':\r\n            style.inner = {position: 'fixed', top: 'auto', left: dims.sidebarLeft,\r\n                  bottom: dims.bottomSpacing, width: dims.sidebarWidth};\r\n            break;\r\n          case 'CONTAINER-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n            let translate = this._getTranslate(0, dims.translateY + 'px');\r\n            \r\n            if( translate )\r\n              style.inner = {transform: translate};\r\n            else \r\n              style.inner = {position: 'absolute', top: dims.translateY, width: dims.sidebarWidth};\r\n            break;\r\n        }\r\n        \r\n        switch( affixType ){\r\n          case 'VIEWPORT-TOP':\r\n          case 'VIEWPORT-BOTTOM':\r\n          case 'VIEWPORT-UNBOTTOM':\r\n          case 'CONTAINER-BOTTOM':\r\n            style.outer = {height: dims.sidebarHeight, position: 'relative'};\r\n            break;\r\n        }\r\n  \r\n        style.outer = StickySidebar.extend({height: '', position: ''}, style.outer);\r\n        style.inner = StickySidebar.extend({position: 'relative', top: '', left: '',\r\n            bottom: '', width: '',  transform: this._getTranslate()}, style.inner);\r\n  \r\n        return style;\r\n      }\r\n     \r\n      /**\r\n       * Cause the sidebar to be sticky according to affix type by adding inline\r\n       * style, adding helper class and trigger events.\r\n       * @function\r\n       * @protected\r\n       * @param {string} force - Update sticky sidebar position by force.\r\n       */\r\n      stickyPosition(force){\r\n        if( this._breakpoint ) return;\r\n  \r\n        force = this._reStyle || force || false;\r\n        \r\n        var offsetTop = this.options.topSpacing;\r\n        var offsetBottom = this.options.bottomSpacing;\r\n  \r\n        var affixType = this.getAffixType();\r\n        var style = this._getStyle(affixType);\r\n        \r\n        if( (this.affixedType != affixType || force) && affixType ){\r\n          let affixEvent = 'affix.' + affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixEvent);\r\n  \r\n          if( 'STATIC' === affixType )\r\n            StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          else\r\n            StickySidebar.addClass(this.sidebar, this.options.stickyClass);\r\n          \r\n          for( let key in style.outer ){\r\n            let _unit = ('number' === typeof style.outer[key]) ? 'px' : '';\r\n            this.sidebar.style[key] = style.outer[key];\r\n          }\r\n  \r\n          for( let key in style.inner ){\r\n            let _unit = ('number' === typeof style.inner[key]) ? 'px' : '';\r\n            this.sidebarInner.style[key] = style.inner[key] + _unit;\r\n          }\r\n          \r\n          let affixedEvent = 'affixed.'+ affixType.toLowerCase().replace('viewport-', '') + EVENT_KEY;\r\n          StickySidebar.eventTrigger(this.sidebar, affixedEvent);\r\n        } else {\r\n          if( this._initialized ) this.sidebarInner.style.left = style.inner.left;\r\n        }\r\n  \r\n        this.affixedType = affixType;\r\n      }\r\n  \r\n      /**\r\n       * Breakdown sticky sidebar when window width is below `options.minWidth` value.\r\n       * @protected\r\n       */\r\n      _widthBreakpoint(){\r\n  \r\n        if( window.innerWidth <= this.options.minWidth ){\r\n          this._breakpoint = true;\r\n          this.affixedType = 'STATIC';\r\n  \r\n          this.sidebar.removeAttribute('style');\r\n          StickySidebar.removeClass(this.sidebar, this.options.stickyClass);\r\n          this.sidebarInner.removeAttribute('style');\r\n        } else {\r\n          this._breakpoint = false;\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Switches between functions stack for each event type, if there's no \r\n       * event, it will re-initialize sticky sidebar.\r\n       * @public\r\n       */\r\n      updateSticky(event = {}){\r\n        if( this._running ) return;\r\n        this._running = true;\r\n  \r\n        ((eventType) => {\r\n\r\n          requestAnimationFrame(() => {\r\n            switch( eventType ){\r\n              // When browser is scrolling and re-calculate just dimensions\r\n              // within scroll. \r\n              case 'scroll':\r\n                this._calcDimensionsWithScroll();\r\n                this.observeScrollDir();\r\n                this.stickyPosition();\r\n                break;\r\n  \r\n              // When browser is resizing or there's no event, observe width\r\n              // breakpoint and re-calculate dimensions.\r\n              case 'resize':\r\n              default: \r\n                this._widthBreakpoint();\r\n                this.calcDimensions();\r\n                this.stickyPosition(true);\r\n                break;\r\n            }\r\n            this._running = false;\r\n          });\r\n        })(event.type);\r\n      }\r\n  \r\n      /**\r\n       * Set browser support features to the public property.\r\n       * @private\r\n       */\r\n      _setSupportFeatures(){\r\n        var support = this.support;\r\n  \r\n        support.transform = StickySidebar.supportTransform();\r\n        support.transform3d = StickySidebar.supportTransform(true);\r\n      }\r\n  \r\n      /**\r\n       * Get translate value, if the browser supports transfrom3d, it will adopt it.\r\n       * and the same with translate. if browser doesn't support both return false.\r\n       * @param {Number} y - Value of Y-axis.\r\n       * @param {Number} x - Value of X-axis.\r\n       * @param {Number} z - Value of Z-axis.\r\n       * @return {String|False}\r\n       */\r\n      _getTranslate(y = 0, x = 0, z = 0){\r\n        if( this.support.transform3d ) return 'translate3d(' + y +', '+ x +', '+ z +')';\r\n        else if( this.support.translate ) return 'translate('+ y +', '+ x +')';\r\n        else return false;\r\n      }\r\n  \r\n      /**\r\n       * Destroy sticky sidebar plugin.\r\n       * @public\r\n       */\r\n      destroy(){\r\n        window.removeEventListener('resize', this, {caption: false});\r\n        window.removeEventListener('scroll', this, {caption: false});\r\n  \r\n        this.sidebar.classList.remove(this.options.stickyClass);\r\n        this.sidebar.style.minHeight = '';\r\n  \r\n        this.sidebar.removeEventListener('update' + EVENT_KEY, this);\r\n  \r\n        var styleReset = {inner: {}, outer: {}};\r\n  \r\n        styleReset.inner = {position: '', top: '', left: '', bottom: '', width: '',  transform: ''};\r\n        styleReset.outer = {height: '', position: ''};\r\n  \r\n        for( let key in styleReset.outer )\r\n          this.sidebar.style[key] = styleReset.outer[key];\r\n  \r\n        for( let key in styleReset.inner )\r\n          this.sidebarInner.style[key] = styleReset.inner[key];\r\n  \r\n        if( this.options.resizeSensor && 'undefined' !== typeof ResizeSensor ){\r\n          ResizeSensor.detach(this.sidebarInner, this.handleEvent);\r\n          ResizeSensor.detach(this.container, this.handleEvent);\r\n        }\r\n      }\r\n  \r\n      /**\r\n       * Determine if the browser supports CSS transform feature.\r\n       * @function\r\n       * @static\r\n       * @param {Boolean} transform3d - Detect transform with translate3d.\r\n       * @return {String}\r\n       */\r\n      static supportTransform(transform3d){\r\n        var result = false,\r\n            property = (transform3d) ? 'perspective' : 'transform',\r\n            upper = property.charAt(0).toUpperCase() + property.slice(1),\r\n            prefixes = ['Webkit', 'Moz', 'O', 'ms'],\r\n            support = document.createElement('support'),\r\n            style = support.style;\r\n  \r\n        (property + ' ' + prefixes.join(upper + ' ') + upper).split(' ').forEach(function(property, i) {\r\n          if (style[property] !== undefined) {\r\n            result = property;\r\n            return false;\r\n          }\r\n        });\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Trigger custom event.\r\n       * @static\r\n       * @param {DOMObject} element - Target element on the DOM.\r\n       * @param {String} eventName - Event name.\r\n       * @param {Object} data - \r\n       */\r\n      static eventTrigger(element, eventName, data){\r\n        try{\r\n          var event = new CustomEvent(eventName, {detail: data});\r\n        } catch(e){\r\n          var event = document.createEvent('CustomEvent');\r\n          event.initCustomEvent(eventName, true, true, data);\r\n        }\r\n        element.dispatchEvent(event);\r\n      }\r\n  \r\n      /**\r\n       * Extend options object with defaults.\r\n       * @function\r\n       * @static\r\n       */\r\n      static extend(defaults, options){\r\n        var results = {};\r\n        for( let key in defaults ){\r\n          if( 'undefined' !== typeof options[key] ) results[key] = options[key];\r\n          else results[key] = defaults[key];\r\n        }\r\n        return results;\r\n      }\r\n  \r\n      /**\r\n       * Get current coordinates left and top of specific element.\r\n       * @static\r\n       */\r\n      static offsetRelative(element){\r\n        var result = {left: 0, top: 0};\r\n\r\n        do{\r\n          let offsetTop = element.offsetTop;\r\n          let offsetLeft = element.offsetLeft;\r\n  \r\n          if( ! isNaN(offsetTop) )\r\n            result.top += offsetTop;\r\n  \r\n          if( ! isNaN(offsetLeft) )\r\n            result.left += offsetLeft;\r\n\r\n          element = ( 'BODY' === element.tagName ) ?\r\n                      element.parentElement : element.offsetParent;\r\n        } while(element)\r\n        return result;\r\n      }\r\n  \r\n      /**\r\n       * Add specific class name to specific element.\r\n       * @static \r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static addClass(element, className){\r\n        if( ! StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.add(className);\r\n          else\r\n            element.className += ' ' + className;\r\n        }\r\n      }\r\n      \r\n      /**\r\n       * Remove specific class name to specific element\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static removeClass(element, className){\r\n        if( StickySidebar.hasClass(element, className) ){\r\n          if (element.classList)\r\n            element.classList.remove(className);\r\n          else\r\n            element.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n        }\r\n      }\r\n\r\n      /**\r\n       * Determine weather the element has specific class name.\r\n       * @static\r\n       * @param {ObjectDOM} element \r\n       * @param {String} className \r\n       */\r\n      static hasClass(element, className){\r\n        if (element.classList)\r\n          return element.classList.contains(className);\r\n        else\r\n          return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\r\n      }\r\n    }\r\n  \r\n    return StickySidebar;\r\n  })();\r\n  \r\n  export default StickySidebar;\r\n  \r\n  // Global\r\n  // -------------------------\r\n  window.StickySidebar = StickySidebar;"]},"metadata":{},"sourceType":"module"}